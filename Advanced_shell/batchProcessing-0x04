#!/bin/bash

# Directory for storing results
output_dir="pokemon_data"
error_log="errors.txt"
mkdir -p "$output_dir"
> "$error_log"

# Pok√©mon list
pokemon_list=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")

# Array to hold background PIDs
declare -a pids=()

# Function to fetch a Pok√©mon
fetch_pokemon() {
    local name="$1"
    local url="https://pokeapi.co/api/v2/pokemon/${name}"
    local output="${output_dir}/${name}.json"

    echo "üîÑ Fetching $name..."
    response=$(curl -s -w "%{http_code}" -o "$output" "$url")

    if [ "$response" -eq 200 ]; then
        echo "‚úÖ Saved $name to $output"
    else
        echo "‚ùå Failed to fetch $name (HTTP $response)" | tee -a "$error_log"
        rm -f "$output"
    fi
}

# Start all fetches in background
for name in "${pokemon_list[@]}"; do
    fetch_pokemon "$name" &
    pids+=($!)
done

# Demonstrate killing one background job (e.g., the 3rd one)
to_kill_pid="${pids[2]}"
echo "üõë Killing process PID $to_kill_pid (simulated cancellation)..."
kill "$to_kill_pid" 2>/dev/null

if [ $? -eq 0 ]; then
    echo "‚ò†Ô∏è  Killed process $to_kill_pid"
else
    echo "‚ö†Ô∏è  Could not kill process $to_kill_pid (maybe already finished)"
fi

# Wait for the rest of the background processes
echo "‚è≥ Waiting for remaining processes to finish..."
for pid in "${pids[@]}"; do
    if [ "$pid" != "$to_kill_pid" ]; then
        wait "$pid"
    fi
done

echo "‚úÖ Batch processing complete."
